# Test Database Model and Unit of Work

This document walks through the test database and Unit of Work used in the EfCore.Boost test suite.  
The test database is intentionally small, but it demonstrates the core modeling, conventions, views, routines, and access patterns used throughout Boost.

---

## The test model (`TestDb.cs`)

**File:** [TestDb.cs](./TestDb.cs)  
**Purpose:** build the database model that gets mapped into a `DbContext`, just like in a normal EF Core project.

This file is the authoritative description of the test database schema.


---

## Declaring the model surface (DbSet<T>)

```csharp
public DbSet<MyTable> MyTables { get; set; }
public DbSet<MyTableRef> MyTableRefs { get; set; }
public DbSet<MyTableRefView> MyTableRefViews { get; set; }
```

These `DbSet<T>` declarations define the **explicit model surface**:

- which entities belong to the model
- what EF Core tooling can see (migrations, model inspection)
- what appears in the EDM, which matters for OData visibility

Declaring view entities here ensures they participate fully in queries, even though they are read-only.

---

## Model building and conventions

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.ApplyEfBoostConventions(this, "my");
    OnModelData(modelBuilder);
}
```

This is the only required model-building code.

- `ApplyEfBoostConventions` reads attributes and applies provider-correct behavior
- the default schema is set to `"my"`
- `OnModelData` seeds test data (see `TestDbData.cs`)

The model expresses intent. Boost translates that intent to each database flavor.

---

## Table and view entities (attribute-driven)

The complete entity definitions are shown below.  
They are intentionally modeled using attributes instead of large fluent blocks, to keep the mental model clear.

<small>

```csharp
[Index(nameof(ParentId), IsUnique = false)]
[Index(nameof(MyInfo), IsUnique = false)]
public class MyTableRef
{
    [DbAutoUid]
    public long Id { get; set; }

    [Required]
    public long ParentId { get; set; }

    [StrMed]
    public string MyInfo { get; set; } = string.Empty;

    public DateTimeOffset LastChanged { get; set; }

    [StrShort]
    public string LastChangedBy { get; set; } = string.Empty;

    [ForeignKey(nameof(ParentId))]
    public MyTable? MyTable { get; set; }
}
```
</small>

Attributes sit next to the properties they affect, making schema intent visible without scrolling into fluent configuration.

The EF Core provider/driver (SqlServer / Npgsql / MySql) together with EfBoost conventions determines the actual mapping from C# to provider-specific SQL.
That includes identifier quoting, schema handling, and provider-specific defaults.

- SQL Server / Azure SQL (schema + brackets)  
  ```CREATE TABLE [my].[MyTableRef] ``` 
- MySQL (schema-as-prefix + backticks)  
  ```CREATE TABLE `my_MyTable` ```
- PostgreSQL (schema + quoted identifiers for case)  
  ```CREATE TABLE my."MyTableRef" ```

The ```[DbAutoUid]``` marks the column Id as prmary key with identity:
- SQL Server: 
  ```[Id] bigint NOT NULL IDENTITY, ...CONSTRAINT [PK_MyTableRef] PRIMARY KEY ([Id]), ``` 
- MySQL
  ``` `Id` bigint NOT NULL AUTO_INCREMENT, ...CONSTRAINT `PK_my_MyTableRef` PRIMARY KEY (`Id`) ```
- PostgreSQL 
  ```"Id" bigint GENERATED BY DEFAULT AS IDENTITY ...CONSTRAINT "PK_MyTableRef" PRIMARY KEY ("Id"),```

---

### View entity and `ViewKey`

<small>

```csharp
[ViewKey(nameof(RefId), nameof(MyId))]
public class MyTableRefView
{
    public long RefId { get; set; }
    public long MyId { get; set; }

    public Guid RowID { get; set; }

    public DateTimeOffset LastChanged { get; set; }

    [StrShort]
    public string LastChangedBy { get; set; } = string.Empty;

    [StrMed]
    public string MyInfo { get; set; } = string.Empty;

    public DateTimeOffset RefLastChanged { get; set; }

    [StrShort]
    public string RefLastChangedBy { get; set; } = string.Empty;
}
```
</small>

`ViewKey` defines a model-level identity for a view.  
It allows EF Core to track and materialize results correctly without creating a database constraint.  
**NOTE:** It is up to you to implement the actual view and place the script file that is picked up during the model build.  
Our expamples of the views are placed in:

- SqlServer: [MsSql.sql](./TestDb/MsSql.sql)
- MySql: [MySql.mysql](./TestDb/MySql.mysql)
- Postgres: [PgSql.pgsql](./TestDb/PgSql.pgsql)

---

## Why attributes instead of fluent configuration?

This test model favors attributes because:

- intent is visible where it matters
- the model is easier to read and reason about
- the schema doubles as documentation

Fluent configuration remains available, but is avoided here unless it is genuinely clearer.

---

## The Unit of Work (`UOWTestDb.cs`)

**File:** [UOWTestDb.cs](./UOWTestDb.cs)  
**Purpose:** define the Unit of Work (UOW) for the test database, exposing repositories and routines.

If the DbContext defines *what the database is*, the Unit of Work defines *how it may be used*.

The UOW is the public gateway to the database.

---

## Repository exposure (the public gateway)

```csharp
public EfRepo<MyTable> MyTables => new(Ctx, DbType);
public EfRepo<MyTableRef> MyTableRefs => new(Ctx, DbType);

// Views are read-only, so we use a read-only repository for those
public EfReadRepo<MyTableRefView> MyTableRefViews => new(Ctx, DbType);
```

- tables are exposed as full read/write repositories
- views are exposed as read-only
- anything not exposed here is not part of the public surface

---

## Routine access (cross-provider)

### Sequence-style routine (list return)

```csharp
public async Task<List<long>> GetNextSequenceIds(int count)
{
    var paList = new List<DbParmInfo> { new("@IdCount", count) };
    return await this.RunRoutineLongListAsync("my", "ReserveMyIds", paList);
}
```

Here we use the helper method **`RunRoutineLongListAsync`** to call a routine that returns a list of `long` values.

The same result could also be achieved using the more general **`SetUpRoutineQuery<long>`** pattern, but this helper exists to keep the common scalar/list cases concise and readable.  
(That more general pattern is shown later in this document.)

This call always resolves to the **provider-correct implementation** of the routine `ReserveMyIds`, regardless of whether the underlying database is SQL Server, PostgreSQL, or MySQL.

### Parameters and portability

Both **parameter order** and **parameter names** matter.

Different database engines bind parameters differently, so for portable routines you should:
- keep parameter names consistent across providers
- pass parameters in the correct order
- use **IN parameters only** for cross-platform consistency

Boost takes care of *how* the routine is invoked for each provider.  
It is your responsibility to implement the routine itself in each database so that it matches Boost’s conventions and expectations.

In this example, the routine `ReserveMyIds` is expected to return a **set of numeric IDs**.

---

## SQL Server / Azure SQL

On SQL Server, `ReserveMyIds` is implemented as a **stored procedure**.

**Native SQL-Invocation:**

```sql
EXEC [my].[ReserveMyIds] @IdCount = @IdCount;
```

**DDL (simplified):**

```sql
CREATE OR ALTER PROCEDURE [my].[ReserveMyIds] (@IdCount INT) AS
BEGIN
    ...
    SELECT @StartBase + i AS ReservedId FROM nums;
END
```

---

## MySQL

On MySQL, `ReserveMyIds` is also implemented as a **stored procedure**.

**Native SQL-Invocation:**

```sql
CALL my_ReserveMyIds(?);
```

**DDL (simplified):**

```sql
CREATE PROCEDURE my_ReserveMyIds (IN IdCount INT)
BEGIN
    ...
    SELECT ReservedId FROM tmp_ReservedIds;
END
```

---

## PostgreSQL

On PostgreSQL, `ReserveMyIds` is implemented as a **function returning a table**.

**Native SQL-Invocation:**

```sql
SELECT * FROM my."ReserveMyIds"(@IdCount);
```

**DDL:**

```sql
CREATE OR REPLACE FUNCTION my."ReserveMyIds"(IdCount INT)
RETURNS TABLE(id BIGINT) AS $$
BEGIN
    RETURN QUERY
    SELECT nextval('my."MySeq"') FROM generate_series(1, IdCount);
END;
$$ LANGUAGE plpgsql;
```

---

## What you do *not* need to worry about

You do **not** need to know or handle these invocation differences in application code.  
EF‑Boost resolves the correct call shape (`EXEC`, `CALL`, or `SELECT`) automatically.

What *does* matter is that the routine exists and behaves consistently across providers.

<small>
P.S. Once a routine is implemented for one database, it is usually straightforward to port it to the others, especially with AI-assisted conversion tools.
</small>

---

## Routine source files

The full routine implementations used by the test database live here:

- SQL Server: [`MsSql.sql`](./TestDb/MsSql.sql)
- MySQL: [`MySql.mysql`](./TestDb/MySql.mysql)
- PostgreSQL: [`PgSql.pgsql`](./TestDb/PgSql.pgsql)


---

### Scalar routine

```csharp
public async Task<long?> GetMaxIdByChanger(string changer)
{
    var paList = new List<DbParmInfo> { new("@Changer", changer) };
    return await RunRoutineLongAsync("my", "GetMaxIdByChanger", paList);
}
```
Here we use the helper function **``` RunRoutineLongAsync ```** to call a routine that returns scalar long value.  
Same rules apply as in the above example.

---

### Parameterized view lookup

```csharp
public async Task<List<MyTableRefView>> GetMyTableRefViewByMyIdAsync(long myId)
{
    var paList = new List<DbParmInfo> { new("@MyId", myId) };
    return await SetUpRoutineQuery<MyTableRefView>("my","GetMyTableRefViewByMyId", paList).ToListAsync();
}
```

This pattern allows parameterized, provider-specific reads while returning strongly typed results.
